////  PlayerBar.m//  Fussball3d////  Created by Roger Engelbert on 10/29/12.//  Copyright 2012 DoneWithComputers. All rights reserved.//#import "PlayerBar.h"#import "Player.h"static NSString * TEAM_1_COLOR = @"66ccff";static NSString * TEAM_2_COLOR = @"ffff66";static float RAD_TO_DEG = 180 / (float)M_PI;@implementation PlayerBar@synthesize selected = _selected, width = _width, touch = _touch;-(void) dealloc {		[_players removeAllObjects];	[_players release];	_players = nil;		[super dealloc];}-(id) initWithView:(Fussball3d *) view withTeam:(int) team numPlayers:(int) playersNum atY:(float) y {	self = [super initWithView:view];		if (self != nil) {		_team = team;        //distance between players		_gap = _view.screenWidth / (playersNum + 1);		_y = _view.screenHeight - y;				_players = [[NSMutableArray array] retain];		Player * player;		for (int i = 0; i < playersNum; i++) {			player = [[[Player alloc] initWithView:_view withTeam:_team at:CGPointMake((i + 1) * _gap, _y)] autorelease];			[_players addObject:player];			[_skin addChild:player.skin];					}		_nextX = _gap;        //width of total occupied section of bar (used for collision with sides)		_width = (playersNum - 1) * _gap + PLAYER_WIDTH;		_canCollide = YES;				_pivot = CGPointMake (0, 0);		_foot = CGPointMake (0, [Player playerLength]);				_vx = _vy = 0;		_playerVector = CGPointMake (0,0);		_skin.z = _view.screenHeight * 0.5 - _y;		_skin.y = [Player playerLength];				_selected = NO;		_friction = 0.85f;	}		return self;}-(NSString *) barColor {	return _team == 1 ? TEAM_1_COLOR : TEAM_2_COLOR;}-(void) collideWithBall:(Ball *) ball {	if (_canCollide) {		if (fabs(ball.y - _y) < PLAYER_RADIUS * 4 || fabs(ball.nextY - _y) < PLAYER_RADIUS * 4) {						int len = _players.count;			float squared_radii = (ball.radius + PLAYER_RADIUS) * (ball.radius + PLAYER_RADIUS);			BOOL collision = NO;			float diffx;			float diffy;			float d1;			float d2;			float angle;			float force;			float t;			Player * player;						for (int i = 0; i < len; i++) {								collision = NO;								player = [_players objectAtIndex:i];								diffx = ball.nextX - player.nextX;				diffy = ball.nextY - player.nextY;								d1 = pow(diffx, 2) + pow(diffy, 2);				d2 = pow(ball.x - player.nextX, 2) + pow(ball.y - player.nextY, 2);								//check squared distance with squared radii				if (d1 <= squared_radii || d2 <= squared_radii) {					collision = YES;				} else {					//if no collision check for time: Ball Now, Next and Player Now					d1 = pow(ball.x - player.x, 2) + pow(ball.y - player.y, 2);					d2 = pow(ball.nextX - player.x, 2) + pow(ball.nextY - player.y, 2);										t = (squared_radii - d1) / (d2-d1);										if (t > 0 && t < 1) { 						collision = YES;					} else {                        //if no collision check for time: Ball Now, Next and Player Next						d1 =  pow(ball.x - player.nextX, 2) + pow(ball.y - player.nextY, 2);						d2 =  pow(ball.nextX - player.nextX, 2) + pow(ball.nextY - player.nextY, 2);						t = (squared_radii - d1) / (d2-d1);												if (t > 0 && t < 1) {							collision = YES;						}											}									}								if (collision ) {										diffx = ball.x - player.x;					diffy = ball.y - player.y;					                    //calculate collision vector					float playerVectorMag = _playerVector.x * _playerVector.x + _playerVector.y * _playerVector.y;					force = sqrt(ball.mag2d * 0.5f + playerVectorMag);                    					angle = atan2(diffy, diffx);										ball.vx =  force * cos(angle);					ball.vy =  force * sin(angle);										ball.x = player.nextX + (PLAYER_RADIUS + ball.radius) * cos(angle);					ball.y = player.nextY + (PLAYER_RADIUS + ball.radius) * sin(angle);										[ball place];					[ball bounceWithForce:[player mag2d]];				}											}					}	}}-(void) processTouchDown:(CGPoint) touch {	_currentTouch = touch;  }-(void) processTouchUp:(CGPoint) touch {	_selected = NO;    }-(void) processTouchMove:(CGPoint) touch {		if (!_selected) return;		//process swipe	float diffy = _currentTouch.y - touch.y;		//process move	float diffx = touch.x - _currentTouch.x;			if (fabs(diffy) > fabs(diffx) * 4) {        //add friction to swipe (rotation)		diffy *= 0.06f;		_vy = diffy;	} else {        //add friction to sideways movement		diffx *= 0.9;		_nextX += diffx;                //check for collision with sides		if (_nextX < PLAYER_WIDTH * 0.5f) {			_nextX = PLAYER_WIDTH * 0.5f;		}				if (_nextX > _view.screenWidth - _width + PLAYER_WIDTH * 0.5f) {			_nextX = _view.screenWidth - _width + PLAYER_WIDTH * 0.5f;		}	}	_currentTouch = touch;}		-(void) update:(float) dt {	    //reduce rotation speed	_vy *= _friction;	    //stop rotation if speed too low	if (fabs(_vy) < 0.01f) _vy = 0;		float prevX = _foot.x;	float prevY = _foot.y;    	//rotate foot point around pivot point	if (_vy != 0) {				float cosValue = cos(-_vy);		float sinValue = sin(-_vy);						float x1 = _foot.x - _pivot.x;		float y1 = _foot.y - _pivot.y;				float x2 = cosValue * x1 - sinValue * y1;		float y2 = cosValue * y1 + sinValue * x1;				_foot.x = _pivot.x + x2;		_foot.y = _pivot.y + y2;			}        //add sidways movement to player vector	float sidewaysVectorX = (fabs(_skin.x - (_nextX + _width * 0.5f - PLAYER_WIDTH * 0.5f - _view.screenWidth * 0.5f)));	_playerVector.x = _foot.x - prevX + sidewaysVectorX * 0.5f;	_playerVector.y = _foot.y - prevY;			int len = _players.count;	Player * player;	for (int i = 0; i < len; i++) {		player = [_players objectAtIndex:i];		player.nextX = _nextX + i * _gap;		player.nextY = _y + (_foot.x - _pivot.x);	}	    //check on foot point distance to pivot to see if foot is close enough to    //the ground for collision detection	_canCollide = (_foot.y - _pivot.y > 0 && 				   _foot.y - _pivot.y > [Player playerLength] * 0.3f);}		-(void) place {		int len = _players.count;	Player * player;	for (int i = 0; i < len; i++) {		player = [_players objectAtIndex:i];		[player place];	}	//position and rotate bar	_skin.x = _nextX + _width * 0.5f - PLAYER_WIDTH * 0.5f - _view.screenWidth * 0.5f;	_skin.rotationX += _vy * RAD_TO_DEG;} 		@end